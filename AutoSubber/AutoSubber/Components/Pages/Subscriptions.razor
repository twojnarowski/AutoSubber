@page "/subscriptions"
@using AutoSubber.Data
@using AutoSubber.Services
@using Microsoft.AspNetCore.Authorization
@using Microsoft.AspNetCore.Identity
@attribute [Authorize]
@inject IYouTubeSubscriptionService SubscriptionService
@inject UserManager<ApplicationUser> UserManager
@inject AuthenticationStateProvider AuthenticationStateProvider
@inject ILogger<Subscriptions> Logger

<PageTitle>YouTube Subscriptions</PageTitle>

<h1>YouTube Subscriptions</h1>

<div class="row">
    <div class="col-md-8">
        @if (isLoading)
        {
            <div class="text-center">
                <div class="spinner-border" role="status">
                    <span class="visually-hidden">Loading...</span>
                </div>
                <p>Loading subscriptions...</p>
            </div>
        }
        else if (subscriptions.Any())
        {
            <p class="text-muted">
                You have @subscriptions.Count subscriptions. 
                @subscriptions.Count(s => s.IsIncluded) are included for automation.
            </p>
            
            <div class="list-group">
                @foreach (var subscription in subscriptions)
                {
                    <div class="list-group-item d-flex justify-content-between align-items-center">
                        <div>
                            <h6 class="mb-1">@subscription.Title</h6>
                            <small class="text-muted">Channel ID: @subscription.ChannelId</small>
                        </div>
                        <div class="form-check form-switch">
                            <input class="form-check-input" 
                                   type="checkbox" 
                                   id="switch-@subscription.Id"
                                   checked="@subscription.IsIncluded"
                                   @onchange="@(async (e) => await ToggleSubscription(subscription.Id, (bool)e.Value!))" />
                            <label class="form-check-label" for="switch-@subscription.Id">
                                @(subscription.IsIncluded ? "Included" : "Excluded")
                            </label>
                        </div>
                    </div>
                }
            </div>
        }
        else if (hasAttemptedFetch)
        {
            <div class="alert alert-info">
                <h4>No subscriptions found</h4>
                <p>We couldn't find any YouTube subscriptions for your account. This could mean:</p>
                <ul>
                    <li>You don't have any YouTube subscriptions</li>
                    <li>There was an issue accessing your YouTube data</li>
                    <li>Your access token may have expired</li>
                </ul>
            </div>
        }
        else
        {
            <div class="alert alert-warning">
                <h4>Subscriptions not loaded</h4>
                <p>Click the "Fetch Subscriptions" button to load your YouTube subscriptions.</p>
            </div>
        }
    </div>
    
    <div class="col-md-4">
        <div class="card">
            <div class="card-body">
                <h5 class="card-title">Manage Subscriptions</h5>
                <p class="card-text">
                    Fetch your latest YouTube subscriptions and manage which channels 
                    should be included for automation.
                </p>
                <button class="btn btn-primary" 
                        @onclick="FetchSubscriptions" 
                        disabled="@isFetching">
                    @if (isFetching)
                    {
                        <span class="spinner-border spinner-border-sm me-2" role="status"></span>
                        <span>Fetching...</span>
                    }
                    else
                    {
                        <span>Fetch Subscriptions</span>
                    }
                </button>
                
                @if (!string.IsNullOrEmpty(statusMessage))
                {
                    <div class="mt-3 alert @(isStatusError ? "alert-danger" : "alert-success")">
                        @statusMessage
                    </div>
                }
            </div>
        </div>
    </div>
</div>

@code {
    private List<Subscription> subscriptions = new();
    private bool isLoading = true;
    private bool isFetching = false;
    private bool hasAttemptedFetch = false;
    private string statusMessage = string.Empty;
    private bool isStatusError = false;

    protected override async Task OnInitializedAsync()
    {
        await LoadSubscriptions();
    }

    private async Task LoadSubscriptions()
    {
        try
        {
            isLoading = true;
            var authState = await AuthenticationStateProvider.GetAuthenticationStateAsync();
            var user = await UserManager.GetUserAsync(authState.User);
            
            if (user != null)
            {
                subscriptions = await SubscriptionService.GetUserSubscriptionsAsync(user.Id);
                hasAttemptedFetch = subscriptions.Any();
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error loading subscriptions");
            SetStatusMessage("Error loading subscriptions", true);
        }
        finally
        {
            isLoading = false;
        }
    }

    private async Task FetchSubscriptions()
    {
        try
        {
            isFetching = true;
            SetStatusMessage("", false);
            
            var authState = await AuthenticationStateProvider.GetAuthenticationStateAsync();
            var user = await UserManager.GetUserAsync(authState.User);
            
            if (user == null)
            {
                SetStatusMessage("User not found", true);
                return;
            }

            var result = await SubscriptionService.FetchAndStoreSubscriptionsAsync(user);
            
            if (result.HasValue)
            {
                SetStatusMessage($"Successfully fetched {result.Value} subscriptions", false);
                hasAttemptedFetch = true;
                await LoadSubscriptions();
            }
            else
            {
                SetStatusMessage("Failed to fetch subscriptions. Please check your Google account connection.", true);
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error fetching subscriptions");
            SetStatusMessage("Error fetching subscriptions", true);
        }
        finally
        {
            isFetching = false;
        }
    }

    private async Task ToggleSubscription(int subscriptionId, bool isIncluded)
    {
        try
        {
            var authState = await AuthenticationStateProvider.GetAuthenticationStateAsync();
            var user = await UserManager.GetUserAsync(authState.User);
            
            if (user == null) return;

            var success = await SubscriptionService.UpdateSubscriptionInclusionAsync(subscriptionId, isIncluded, user.Id);
            
            if (success)
            {
                // Update the local state
                var subscription = subscriptions.FirstOrDefault(s => s.Id == subscriptionId);
                if (subscription != null)
                {
                    subscription.IsIncluded = isIncluded;
                }
                
                SetStatusMessage($"Subscription updated successfully", false);
            }
            else
            {
                SetStatusMessage("Failed to update subscription", true);
                // Reload to get the correct state
                await LoadSubscriptions();
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error toggling subscription {SubscriptionId}", subscriptionId);
            SetStatusMessage("Error updating subscription", true);
        }
    }

    private void SetStatusMessage(string message, bool isError)
    {
        statusMessage = message;
        isStatusError = isError;
        StateHasChanged();
        
        // Clear message after 5 seconds
        if (!string.IsNullOrEmpty(message))
        {
            _ = Task.Delay(5000).ContinueWith(_ => 
            {
                statusMessage = string.Empty;
                InvokeAsync(StateHasChanged);
            });
        }
    }
}